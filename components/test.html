<!-- public/ws-mic-stream.html -->
<!doctype html>
<html>
  <body>
    <button id="startCall">Create call & connect</button>
    <button id="startMic" disabled>Start mic stream</button>
    <button id="stopMic" disabled>Stop mic stream</button>
    <pre id="log" style="white-space:pre-wrap"></pre>

    <script>
      const $log = document.getElementById("log");
      const log = (o) => { $log.textContent += JSON.stringify(o, null, 2) + "\n\n"; console.log(o); };

      let ws = null;
      let audioCtx = null;
      let sourceNode = null;
      let processorNode = null;
      let localStream = null;

      document.getElementById("startCall").onclick = async () => {
        log({ step: "requesting /api/create-call" });
        const resp = await fetch("/api/create-call", { method: "POST", headers: { "Content-Type": "application/json" }, body: "{}" });
        const body = await resp.json();
        log({ serverResponse: body });

        const wsUrl = body?.vapiBody?.transport?.websocketCallUrl;
        if (!wsUrl) { log({ error: "no websocketCallUrl in response" }); return; }

        ws = new WebSocket(wsUrl);
        ws.binaryType = "arraybuffer";
        ws.onopen = () => {
          log({ ws: "open" });
          document.getElementById("startMic").disabled = false;
        };
        ws.onmessage = (ev) => {
          if (typeof ev.data === "string") {
            try { log({ wsMessage: JSON.parse(ev.data) }); } catch { log({ wsMessageText: ev.data }); }
          } else {
            log({ wsMessage: "[binary]", byteLength: ev.data.byteLength });
          }
        };
        ws.onclose = () => { log({ ws: "closed" }); cleanupMic(); };
        ws.onerror = (e) => log({ ws: "error", err: String(e) });
      };

      document.getElementById("startMic").onclick = async () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) { log({ error: "WebSocket not open" }); return; }
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        } catch (e) {
          log({ micError: String(e) }); return;
        }

        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        sourceNode = audioCtx.createMediaStreamSource(localStream);

        // ScriptProcessor size: 4096, 2048, 1024... choose a balanced buffer.
        const bufferSize = 4096;
        processorNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);

        const targetSampleRate = 16000;

        processorNode.onaudioprocess = (evt) => {
          const inputBuffer = evt.inputBuffer.getChannelData(0); // Float32Array
          const downsampled = downsampleBuffer(inputBuffer, audioCtx.sampleRate, targetSampleRate);
          if (!downsampled) { return; }
          const pcm16 = floatTo16BitPCM(downsampled);
          // send raw PCM16LE as ArrayBuffer
          if (ws && ws.readyState === WebSocket.OPEN) ws.send(pcm16.buffer);
        };

        sourceNode.connect(processorNode);
        processorNode.connect(audioCtx.destination); // required in many browsers to keep processor running

        document.getElementById("startMic").disabled = true;
        document.getElementById("stopMic").disabled = false;
        log({ mic: "streaming started", sampleRate: audioCtx.sampleRate });
      };

      document.getElementById("stopMic").onclick = () => {
        cleanupMic();
        log({ mic: "stopped" });
      };

      function cleanupMic() {
        if (processorNode) { processorNode.disconnect(); processorNode.onaudioprocess = null; processorNode = null; }
        if (sourceNode) { sourceNode.disconnect(); sourceNode = null; }
        if (audioCtx) { try { audioCtx.close(); } catch(e){} audioCtx = null; }
        if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
        document.getElementById("startMic").disabled = true;
        document.getElementById("stopMic").disabled = true;
      }

      // helper: downsample Float32Array from inputSampleRate -> outputSampleRate
      function downsampleBuffer(buffer, inputSampleRate, outputSampleRate) {
        if (outputSampleRate === inputSampleRate) return buffer;
        if (outputSampleRate > inputSampleRate) {
          console.warn("outputSampleRate > inputSampleRate: skipping upsample");
          return buffer;
        }
        const sampleRateRatio = inputSampleRate / outputSampleRate;
        const newLength = Math.round(buffer.length / sampleRateRatio);
        const result = new Float32Array(newLength);
        let offsetResult = 0;
        let offsetBuffer = 0;
        while (offsetResult < result.length) {
          const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
          // average the samples between offsetBuffer & nextOffsetBuffer
          let accum = 0, count = 0;
          for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
            accum += buffer[i];
            count++;
          }
          result[offsetResult] = count ? (accum / count) : 0;
          offsetResult++;
          offsetBuffer = nextOffsetBuffer;
        }
        return result;
      }

      // convert Float32Array (-1..1) to Int16Array little-endian
      function floatTo16BitPCM(float32Array) {
        const output = new Int16Array(float32Array.length);
        for (let i = 0; i < float32Array.length; i++) {
          let s = Math.max(-1, Math.min(1, float32Array[i]));
          output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        return output;
      }
    </script>
  </body>
</html>
